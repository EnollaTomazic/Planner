{"version":3,"file":"static/chunks/9047.d457965e5bc4270d.js","mappings":"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","sources":["webpack://_N_E/./src/lib/metrics/llmTokens.ts","webpack://_N_E/./src/ai/safety.ts","webpack://_N_E/./src/lib/assistant/plannerAgent.ts","webpack://_N_E/./src/lib/assistant/safe-mode.ts","webpack://_N_E/./src/lib/assistant/plannerAssistantAction.ts"],"sourcesContent":["export interface LlmAgentMetadata {\n  readonly id: string;\n  readonly label?: string;\n  readonly kind?: string;\n}\n\nexport interface LlmAgentUsage extends LlmAgentMetadata {\n  readonly tokens: number;\n  readonly share: number;\n}\n\nexport interface LlmTokenUsageSummary {\n  readonly totalTokens: number;\n  readonly agents: readonly LlmAgentUsage[];\n}\n\ntype UsageRecord = {\n  metadata: LlmAgentMetadata;\n  tokens: number;\n};\n\nconst usageStore = new Map<string, UsageRecord>();\n\nlet aggregateTokens = 0;\n\nfunction normalizeText(value: string | undefined): string | undefined {\n  if (typeof value !== \"string\") {\n    return undefined;\n  }\n\n  const trimmed = value.trim();\n  return trimmed.length > 0 ? trimmed : undefined;\n}\n\nfunction normalizeMetadata(metadata: LlmAgentMetadata): LlmAgentMetadata {\n  const normalizedId = normalizeText(metadata.id);\n  const normalizedLabel = normalizeText(metadata.label);\n  const normalizedKind = normalizeText(metadata.kind);\n\n  return {\n    id: normalizedId ?? \"\",\n    ...(normalizedLabel !== undefined ? { label: normalizedLabel } : {}),\n    ...(normalizedKind !== undefined ? { kind: normalizedKind } : {}),\n  } satisfies LlmAgentMetadata;\n}\n\nfunction mergeMetadata(\n  existing: LlmAgentMetadata | undefined,\n  incoming: LlmAgentMetadata,\n): LlmAgentMetadata {\n  return {\n    id: incoming.id,\n    ...(existing?.label ? { label: existing.label } : {}),\n    ...(existing?.kind ? { kind: existing.kind } : {}),\n    ...(incoming.label !== undefined ? { label: incoming.label } : {}),\n    ...(incoming.kind !== undefined ? { kind: incoming.kind } : {}),\n  } satisfies LlmAgentMetadata;\n}\n\nfunction normalizeTokenCount(value: number): number | null {\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    return null;\n  }\n\n  if (value < 0) {\n    return null;\n  }\n\n  const rounded = Math.round(value);\n  return rounded > 0 ? rounded : 0;\n}\n\nfunction deleteUsage(id: string, previousTokens: number): void {\n  usageStore.delete(id);\n  aggregateTokens -= previousTokens;\n\n  if (aggregateTokens < 0) {\n    aggregateTokens = 0;\n  }\n}\n\nexport function recordLlmTokenUsage(\n  metadata: LlmAgentMetadata,\n  tokens: number,\n): void {\n  const normalizedMetadata = normalizeMetadata(metadata);\n\n  if (normalizedMetadata.id.length === 0) {\n    return;\n  }\n\n  const normalizedTokens = normalizeTokenCount(tokens);\n\n  if (normalizedTokens === null) {\n    return;\n  }\n\n  const existing = usageStore.get(normalizedMetadata.id);\n  const previousTokens = existing?.tokens ?? 0;\n\n  if (normalizedTokens === 0) {\n    if (existing) {\n      deleteUsage(normalizedMetadata.id, previousTokens);\n    }\n    return;\n  }\n\n  const mergedMetadata = mergeMetadata(existing?.metadata, normalizedMetadata);\n\n  usageStore.set(normalizedMetadata.id, {\n    metadata: mergedMetadata,\n    tokens: normalizedTokens,\n  });\n\n  aggregateTokens += normalizedTokens - previousTokens;\n\n  if (aggregateTokens < 0) {\n    aggregateTokens = 0;\n  }\n}\n\nexport function getLlmTokenUsageSummary(): LlmTokenUsageSummary {\n  const safeTotal = aggregateTokens > 0 ? aggregateTokens : 0;\n\n  const agents = Array.from(usageStore.values())\n    .filter((record) => record.tokens > 0)\n    .map<LlmAgentUsage>((record) => {\n      const share = safeTotal === 0 ? 0 : record.tokens / safeTotal;\n\n      return {\n        ...record.metadata,\n        tokens: record.tokens,\n        share,\n      } satisfies LlmAgentUsage;\n    })\n    .sort((a, b) => {\n      if (b.tokens !== a.tokens) {\n        return b.tokens - a.tokens;\n      }\n\n      return a.id.localeCompare(b.id);\n    });\n\n  return {\n    totalTokens: safeTotal,\n    agents,\n  } satisfies LlmTokenUsageSummary;\n}\n\nexport function resetLlmTokenUsage(): void {\n  usageStore.clear();\n  aggregateTokens = 0;\n}\n","import { z } from \"zod\";\n\nimport { isSafeModeEnabled } from \"@/lib/features\";\nimport type { LlmAgentMetadata } from \"@/lib/metrics/llmTokens\";\nimport { recordLlmTokenUsage } from \"@/lib/metrics/llmTokens\";\nimport { sanitizeText } from \"@/lib/utils\";\n\nconst CONTROL_CHAR_PATTERN = /[\\u0000-\\u0008\\u000b\\u000c\\u000e-\\u001f\\u007f\\u2028\\u2029]/g;\nconst INVISIBLE_CHAR_PATTERN = /[\\u200b-\\u200f\\u202a-\\u202e\\u2060-\\u2064\\u2066-\\u2069\\ufeff]/gi;\nconst COLLAPSE_SPACES_PATTERN = /[ \\t\\f\\v]+/g;\nconst FALLBACK_MAX_INPUT_LENGTH = 16_000;\nconst FALLBACK_TOKENS_PER_CHARACTER = 4;\nconst SAFE_MODE_TOKEN_CEILING_FALLBACK = 8_000;\n\nconst SAFE_MODE_RESPONSE_RESERVE = resolveNumericEnv(\n  \"SAFE_MODE_RESPONSE_RESERVE\",\n  512,\n  {\n    min: 0,\n    integer: true,\n  },\n);\nconst SAFE_MODE_TEMPERATURE_CEILING = resolveNumericEnv(\n  \"SAFE_MODE_TEMPERATURE_CEILING\",\n  0.4,\n  {\n    min: 0,\n  },\n);\nconst SAFE_MODE_MAX_TOOL_CALLS = resolveNumericEnv(\n  \"SAFE_MODE_MAX_TOOL_CALLS\",\n  1,\n  {\n    min: 0,\n    integer: true,\n  },\n);\n\nconst warnedMessages = new Set<string>();\n\ntype IssuePathSegment = string | number;\n\nfunction normalizeIssuePath(path: ReadonlyArray<PropertyKey>): IssuePathSegment[] {\n  const normalized: IssuePathSegment[] = [];\n\n  for (const segment of path) {\n    if (typeof segment === \"string\" || typeof segment === \"number\") {\n      normalized.push(segment);\n    } else {\n      normalized.push(segment.description ?? segment.toString());\n    }\n  }\n\n  return normalized;\n}\n\nfunction normalizeIssueMessage(issue: z.ZodIssue): string {\n  if (\n    issue.code === z.ZodIssueCode.invalid_type &&\n    typeof issue.message === \"string\" &&\n    /received undefined$/u.test(issue.message)\n  ) {\n    return \"Required\";\n  }\n\n  return issue.message;\n}\n\nfunction warnOnce(key: string, message: string): void {\n  if (typeof console === \"undefined\") {\n    return;\n  }\n  if (warnedMessages.has(key)) {\n    return;\n  }\n  warnedMessages.add(key);\n  console.warn(message);\n}\n\nfunction reportTokenEstimateIssue(index: number, raw: unknown, reason: string): void {\n  const printable = typeof raw === \"number\" ? raw.toString() : JSON.stringify(raw);\n  const key = `estimate:${index}:${reason}`;\n  warnOnce(\n    key,\n    `[ai.safety] Token estimator produced ${reason} for message index ${index}; clamping \"${printable}\" to a safe integer budget.`,\n  );\n}\n\nfunction formatIssuePath(path: ReadonlyArray<IssuePathSegment>): string {\n  if (path.length === 0) {\n    return \"<root>\";\n  }\n  return path.reduce<string>((acc, segment) => {\n    if (typeof segment === \"number\") {\n      return `${acc}[${segment}]`;\n    }\n    return acc.length === 0 ? segment : `${acc}.${segment}`;\n  }, \"\");\n}\n\nfunction reportSchemaValidationFailure(label: string, error: unknown): void {\n  if (error instanceof z.ZodError) {\n    const summary = error.issues\n      .map((issue) => {\n        const path = normalizeIssuePath(issue.path);\n        const message = normalizeIssueMessage(issue);\n        return `${formatIssuePath(path)} → ${message}`;\n      })\n      .join(\"; \");\n    const key = `schema:${label}:${summary}`;\n    warnOnce(key, `[ai.safety] ${label} failed schema validation: ${summary}`);\n    return;\n  }\n\n  const description = error instanceof Error ? `${error.name}: ${error.message}` : String(error);\n  const key = `schema:${label}:${description}`;\n  warnOnce(key, `[ai.safety] ${label} validation threw: ${description}`);\n}\n\ntype SegmenterConstructor =\n  | (new (locale?: string, options?: Intl.SegmenterOptions) => Intl.Segmenter)\n  | undefined;\n\nlet cachedSegmenter: Intl.Segmenter | null | undefined;\n\nfunction getUnicodeSegments(input: string): string[] {\n  if (input.length === 0) {\n    return [];\n  }\n\n  if (cachedSegmenter === undefined) {\n    const intlApi =\n      typeof Intl !== \"undefined\"\n        ? (Intl as typeof Intl & { Segmenter?: typeof Intl.Segmenter })\n        : undefined;\n    const segmenterCtor: SegmenterConstructor = intlApi?.Segmenter;\n    cachedSegmenter =\n      typeof segmenterCtor === \"function\"\n        ? new segmenterCtor(undefined, { granularity: \"grapheme\" })\n        : null;\n  }\n\n  const segmenter = cachedSegmenter;\n\n  if (segmenter) {\n    return Array.from(segmenter.segment(input), (segment) => segment.segment);\n  }\n\n  return Array.from(input);\n}\n\nfunction unicodeLength(input: string): number {\n  return getUnicodeSegments(input).length;\n}\n\nfunction unicodeTruncate(input: string, maxLength: number): string {\n  if (maxLength <= 0) {\n    return \"\";\n  }\n\n  const segments = getUnicodeSegments(input);\n\n  if (segments.length <= maxLength) {\n    return input;\n  }\n\n  return segments.slice(0, maxLength).join(\"\");\n}\n\nconst ENABLED_FLAG_VALUES = new Set([\"1\", \"true\", \"on\", \"yes\"]);\n\ninterface NumericEnvOptions {\n  readonly min?: number;\n  readonly integer?: boolean;\n}\n\nfunction reportNumericEnvIssue(name: string, raw: string, reason: string): void {\n  const trimmed = raw.trim();\n  const key = `numeric:${name}:${reason}:${trimmed}`;\n  warnOnce(key, `[ai.safety] Ignoring ${name} value \"${trimmed}\" (${reason}).`);\n}\n\nfunction resolveNumericEnv(\n  names: string | readonly string[],\n  fallback: number,\n  options: NumericEnvOptions = {},\n): number {\n  if (typeof process === \"undefined\") {\n    return fallback;\n  }\n\n  const candidates = Array.isArray(names) ? names : [names];\n\n  for (const name of candidates) {\n    const raw = process.env[name];\n\n    if (typeof raw !== \"string\") {\n      continue;\n    }\n\n    const normalized = raw.trim();\n\n    if (normalized.length === 0) {\n      reportNumericEnvIssue(name, raw, \"empty string\");\n      continue;\n    }\n\n    const parsed = Number(normalized);\n\n    if (!Number.isFinite(parsed)) {\n      reportNumericEnvIssue(name, raw, \"non-numeric value\");\n      continue;\n    }\n\n    const value = options.integer ? Math.trunc(parsed) : parsed;\n\n    if (Number.isNaN(value)) {\n      reportNumericEnvIssue(name, raw, \"not a number\");\n      continue;\n    }\n\n    if (options.min !== undefined && value < options.min) {\n      reportNumericEnvIssue(name, raw, `below minimum ${options.min}`);\n      continue;\n    }\n\n    return value;\n  }\n\n  return fallback;\n}\n\nfunction getDefaultMaxInputLength(): number {\n  return resolveNumericEnv(\n    \"AI_MAX_INPUT_LENGTH\",\n    FALLBACK_MAX_INPUT_LENGTH,\n    {\n      min: 1,\n      integer: true,\n    },\n  );\n}\n\nfunction getDefaultTokensPerCharacter(): number {\n  return resolveNumericEnv(\n    [\"AI_TOKENS_PER_CHAR\", \"AI_TOKENS_PER_CHARACTER\"],\n    FALLBACK_TOKENS_PER_CHARACTER,\n    {\n      min: Number.EPSILON,\n    },\n  );\n}\n\nfunction getSafeModeTokenCeiling(): number {\n  return resolveNumericEnv(\n    \"SAFE_MODE_TOKEN_CEILING\",\n    SAFE_MODE_TOKEN_CEILING_FALLBACK,\n    {\n      min: 1,\n      integer: true,\n    },\n  );\n}\n\nfunction isServerSafeModeExplicitlyEnabled(): boolean {\n  if (typeof process === \"undefined\") {\n    return false;\n  }\n\n  const raw = process.env.SAFE_MODE;\n\n  if (typeof raw !== \"string\") {\n    return false;\n  }\n\n  const normalized = raw.trim().toLowerCase();\n\n  if (normalized.length === 0) {\n    return false;\n  }\n\n  return ENABLED_FLAG_VALUES.has(normalized);\n}\n\nexport interface SanitizedInputOptions {\n  readonly maxLength?: number;\n  readonly allowMarkup?: boolean;\n}\n\nexport function sanitizePrompt(\n  raw: string,\n  options: SanitizedInputOptions = {},\n): string {\n  const { maxLength = getDefaultMaxInputLength(), allowMarkup = false } = options;\n  const resolvedMaxLength = Number.isFinite(maxLength)\n    ? Math.max(Math.trunc(maxLength), 0)\n    : getDefaultMaxInputLength();\n  const normalized = raw\n    .replace(/\\r\\n?/g, \"\\n\")\n    .replace(CONTROL_CHAR_PATTERN, \"\")\n    .replace(INVISIBLE_CHAR_PATTERN, \"\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .split(\"\\n\")\n    .map((line) => line.replace(COLLAPSE_SPACES_PATTERN, \" \").trimEnd())\n    .join(\"\\n\")\n    .trim();\n\n  const truncated =\n    resolvedMaxLength === 0 ? \"\" : unicodeTruncate(normalized, resolvedMaxLength);\n\n  return allowMarkup ? truncated : sanitizeText(truncated);\n}\n\nexport const sanitizePromptInput = sanitizePrompt;\n\nexport interface TokenBudgetContent {\n  readonly content: string;\n  readonly pinned?: boolean;\n}\n\nexport interface TokenBudgetOptions {\n  readonly maxTokens: number;\n  readonly reservedForResponse?: number;\n  readonly estimateTokens?: (content: string) => number;\n  readonly agent?: LlmAgentMetadata;\n}\n\nexport interface TokenBudgetResult<T extends TokenBudgetContent> {\n  readonly messages: readonly T[];\n  readonly removedCount: number;\n  readonly totalTokens: number;\n  readonly availableTokens: number;\n}\n\nfunction defaultTokenEstimator(content: string): number {\n  const tokensPerCharacter = getDefaultTokensPerCharacter();\n  const characterCount = unicodeLength(content);\n  if (characterCount === 0) {\n    return 0;\n  }\n  return Math.ceil(characterCount / tokensPerCharacter);\n}\n\nfunction normalizeTokenEstimate(raw: number, index: number): number {\n  if (!Number.isFinite(raw)) {\n    reportTokenEstimateIssue(index, raw, \"a non-finite value\");\n    return 0;\n  }\n\n  if (raw < 0) {\n    reportTokenEstimateIssue(index, raw, \"a negative value\");\n    return 0;\n  }\n\n  if (!Number.isInteger(raw)) {\n    reportTokenEstimateIssue(index, raw, \"a fractional value\");\n  }\n\n  return Math.ceil(raw);\n}\n\nfunction enforceTokenBudgetInternal<T extends TokenBudgetContent>(\n  messages: readonly T[],\n  options: TokenBudgetOptions,\n): TokenBudgetResult<T> {\n  const estimator = options.estimateTokens ?? defaultTokenEstimator;\n  const incomingReserved = options.reservedForResponse ?? 0;\n  const reserved = Number.isFinite(incomingReserved)\n    ? Math.max(Math.floor(incomingReserved), 0)\n    : 0;\n  const clientSafeMode = isSafeModeEnabled();\n  const serverSafeMode = isServerSafeModeExplicitlyEnabled();\n  const safeMode = clientSafeMode && serverSafeMode;\n  const safeReserved = safeMode\n    ? Math.max(reserved, SAFE_MODE_RESPONSE_RESERVE)\n    : reserved;\n  const incomingMaxTokens = Number.isFinite(options.maxTokens)\n    ? Math.max(Math.floor(options.maxTokens), 0)\n    : 0;\n  const safeMaxTokens = safeMode\n    ? Math.min(incomingMaxTokens, getSafeModeTokenCeiling())\n    : incomingMaxTokens;\n  const availableTokens = Math.max(safeMaxTokens - safeReserved, 0);\n\n  const kept: T[] = [];\n  let used = 0;\n  let removed = 0;\n\n  for (let index = messages.length - 1; index >= 0; index -= 1) {\n    const message = messages[index]!;\n    const estimate = estimator(message.content);\n    const tokens = normalizeTokenEstimate(estimate, index);\n    if (message.pinned) {\n      kept.push(message);\n      used += tokens;\n      continue;\n    }\n    if (used + tokens > availableTokens) {\n      removed += 1;\n      continue;\n    }\n    kept.push(message);\n    used += tokens;\n  }\n\n  kept.reverse();\n\n  const result: TokenBudgetResult<T> = {\n    messages: kept,\n    removedCount: removed,\n    totalTokens: used,\n    availableTokens,\n  };\n\n  if (options.agent) {\n    recordLlmTokenUsage(options.agent, result.totalTokens);\n  }\n\n  return result;\n}\n\nexport interface TokenCapResult {\n  readonly content: string | null;\n  readonly removed: boolean;\n  readonly totalTokens: number;\n  readonly availableTokens: number;\n}\n\nexport function capTokens(\n  content: string,\n  options: TokenBudgetOptions & { pinned?: boolean },\n): TokenCapResult;\nexport function capTokens<T extends TokenBudgetContent>(\n  messages: readonly T[],\n  options: TokenBudgetOptions,\n): TokenBudgetResult<T>;\nexport function capTokens<T extends TokenBudgetContent>(\n  input: string | readonly T[],\n  options: TokenBudgetOptions & { pinned?: boolean },\n): TokenBudgetResult<T> | TokenCapResult {\n  if (typeof input === \"string\") {\n    const { pinned, ...restOptions } = options as TokenBudgetOptions & { pinned?: boolean };\n    const result = enforceTokenBudgetInternal(\n      [\n        {\n          content: input,\n          pinned,\n        },\n      ],\n      restOptions,\n    );\n    const kept = result.messages[0];\n    return {\n      content: kept?.content ?? null,\n      removed: kept === undefined,\n      totalTokens: result.totalTokens,\n      availableTokens: result.availableTokens,\n    };\n  }\n\n  return enforceTokenBudgetInternal(input, options as TokenBudgetOptions);\n}\n\nexport function enforceTokenBudget<T extends TokenBudgetContent>(\n  messages: readonly T[],\n  options: TokenBudgetOptions,\n): TokenBudgetResult<T> {\n  return capTokens(messages, options);\n}\n\nexport interface SchemaValidationIssue {\n  readonly path: ReadonlyArray<string | number>;\n  readonly pathText: string;\n  readonly message: string;\n  readonly code?: string;\n}\n\nexport interface SchemaValidationFailure {\n  readonly label: string;\n  readonly issues: readonly SchemaValidationIssue[];\n  readonly cause?: unknown;\n}\n\nexport interface SchemaValidationOptions {\n  readonly label?: string;\n}\n\nexport interface SchemaValidationSuccess<T> {\n  readonly success: true;\n  readonly data: T;\n}\n\nexport interface SchemaValidationErrorResult {\n  readonly success: false;\n  readonly error: SchemaValidationFailure;\n}\n\nexport type SchemaValidationResult<T> =\n  | SchemaValidationSuccess<T>\n  | SchemaValidationErrorResult;\n\nexport function guardResponse<T>(\n  value: unknown,\n  schema: z.ZodType<T>,\n  options: SchemaValidationOptions = {},\n): SchemaValidationResult<T> {\n  const { label = \"AI response\" } = options;\n  try {\n    const parsed = schema.parse(value);\n    return {\n      success: true,\n      data: parsed,\n    };\n  } catch (error) {\n    reportSchemaValidationFailure(label, error);\n    if (error instanceof z.ZodError) {\n      const issues = error.issues.map<SchemaValidationIssue>((issue: z.ZodIssue) => {\n        const path = normalizeIssuePath(issue.path);\n        return {\n          path,\n          pathText: formatIssuePath(path),\n          message: normalizeIssueMessage(issue),\n          code: issue.code,\n        } satisfies SchemaValidationIssue;\n      });\n\n      return {\n        success: false,\n        error: {\n          label,\n          issues,\n          cause: error,\n        },\n      };\n    }\n\n    const message =\n      error instanceof Error ? error.message : \"Unexpected validation error\";\n\n    return {\n      success: false,\n      error: {\n        label,\n        issues: [\n          {\n            path: [],\n            pathText: formatIssuePath([]),\n            message,\n          },\n        ],\n        cause: error,\n      },\n    };\n  }\n}\n\nexport const validateSchema = guardResponse;\n\nexport interface StopSequenceOptions {\n  readonly stopSequences?: readonly string[];\n  readonly safeModeStopSequences?: readonly string[];\n}\n\nexport function withStopSequences<T extends { stopSequences?: readonly string[] }>(\n  payload: T,\n  options: StopSequenceOptions = {},\n): T & { stopSequences?: readonly string[] } {\n  const baseSequences = options.stopSequences ?? payload.stopSequences ?? [];\n  const safeModeSequences = options.safeModeStopSequences ?? baseSequences;\n  const targetSequences = isSafeModeEnabled() ? safeModeSequences : baseSequences;\n  const normalized = Array.from(\n    new Set(\n      targetSequences.filter(\n        (sequence): sequence is string =>\n          typeof sequence === \"string\" && sequence.trim().length > 0,\n      ),\n    ),\n  );\n\n  if (normalized.length === 0) {\n    const clone = { ...payload } as T & { stopSequences?: readonly string[] };\n    if (payload.stopSequences !== undefined || options.stopSequences !== undefined) {\n      clone.stopSequences = [];\n    } else {\n      delete clone.stopSequences;\n    }\n    return clone;\n  }\n\n  return {\n    ...payload,\n    stopSequences: normalized,\n  };\n}\n\nexport interface RetryOptions {\n  readonly maxAttempts?: number;\n  readonly initialDelayMs?: number;\n  readonly maxDelayMs?: number;\n  readonly jitterRatio?: number;\n  readonly signal?: AbortSignal;\n  readonly onRetry?: (context: {\n    readonly attempt: number;\n    readonly delayMs: number;\n    readonly error: unknown;\n  }) => void;\n}\n\nconst DEFAULT_MAX_ATTEMPTS = 3;\nconst DEFAULT_INITIAL_DELAY_MS = 250;\nconst DEFAULT_MAX_DELAY_MS = 4_000;\nconst DEFAULT_JITTER_RATIO = 0.25;\n\nfunction sleep(delayMs: number, signal?: AbortSignal): Promise<void> {\n  if (delayMs <= 0) return Promise.resolve();\n  return new Promise<void>((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      cleanup();\n      resolve();\n    }, delayMs);\n\n    const cleanup = () => {\n      clearTimeout(timeout);\n      signal?.removeEventListener(\"abort\", handleAbort);\n    };\n\n    const handleAbort = () => {\n      cleanup();\n      reject(signal?.reason instanceof Error ? signal.reason : new Error(\"Aborted\"));\n    };\n\n    if (signal) {\n      if (signal.aborted) {\n        cleanup();\n        reject(signal.reason instanceof Error ? signal.reason : new Error(\"Aborted\"));\n        return;\n      }\n      signal.addEventListener(\"abort\", handleAbort);\n    }\n  });\n}\n\nexport async function retryWithJitter<T>(\n  operation: (context: { readonly attempt: number; readonly signal: AbortSignal }) => Promise<T>,\n  options: RetryOptions = {},\n): Promise<T> {\n  const {\n    maxAttempts = DEFAULT_MAX_ATTEMPTS,\n    initialDelayMs = DEFAULT_INITIAL_DELAY_MS,\n    maxDelayMs = DEFAULT_MAX_DELAY_MS,\n    jitterRatio = DEFAULT_JITTER_RATIO,\n    signal,\n    onRetry,\n  } = options;\n\n  let attempt = 0;\n  let delayMs = initialDelayMs;\n  const retryController = new AbortController();\n  const unlinkAbortSignals = signal\n    ? linkAbortSignals(retryController, signal)\n    : undefined;\n  const linkedSignal = retryController.signal;\n\n  try {\n    while (attempt < maxAttempts) {\n      attempt += 1;\n      try {\n        return await operation({ attempt, signal: linkedSignal });\n      } catch (error) {\n        if (linkedSignal.aborted) {\n          throw linkedSignal.reason ?? error;\n        }\n        if (attempt >= maxAttempts) {\n          throw error;\n        }\n        const jitter = 1 + (Math.random() * 2 - 1) * jitterRatio;\n        const nextDelay = Math.min(maxDelayMs, delayMs * jitter);\n        onRetry?.({ attempt, delayMs: nextDelay, error });\n        await sleep(nextDelay, linkedSignal);\n        delayMs = Math.min(maxDelayMs, nextDelay * 2);\n      }\n    }\n  } finally {\n    unlinkAbortSignals?.();\n  }\n\n  throw new Error(\"retryWithJitter exhausted all attempts without resolving\");\n}\n\nexport type ToolChoiceMode = \"auto\" | \"none\" | \"required\";\n\nexport interface ToolChoiceConfig {\n  readonly mode: ToolChoiceMode;\n  readonly maxToolCalls?: number;\n}\n\nexport interface ModelSafetyConfig {\n  readonly temperature?: number;\n  readonly topP?: number;\n  readonly toolChoice?: ToolChoiceConfig;\n}\n\nexport interface ModelSafetyResult extends ModelSafetyConfig {\n  readonly temperature: number;\n  readonly toolChoice: ToolChoiceConfig;\n  readonly safeMode: boolean;\n}\n\nconst DEFAULT_TEMPERATURE = 0.7;\nconst MIN_TEMPERATURE = 0;\nconst MAX_TEMPERATURE = 2;\nconst MIN_TOP_P = Number.EPSILON;\nconst MAX_TOP_P = 1;\n\nfunction normalizeTemperature(value: number | undefined): number {\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    return DEFAULT_TEMPERATURE;\n  }\n\n  const clamped = Math.min(Math.max(value, MIN_TEMPERATURE), MAX_TEMPERATURE);\n  return Number.isNaN(clamped) ? DEFAULT_TEMPERATURE : clamped;\n}\n\nfunction normalizeTopP(value: number | undefined): number | undefined {\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    return undefined;\n  }\n\n  const clamped = Math.min(Math.max(value, MIN_TOP_P), MAX_TOP_P);\n  return Number.isNaN(clamped) ? undefined : clamped;\n}\n\nfunction normalizeMaxToolCalls(value: number | undefined): number | undefined {\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    return undefined;\n  }\n\n  const rounded = Math.max(0, Math.trunc(value));\n  return Number.isNaN(rounded) ? undefined : rounded;\n}\n\nfunction normalizeToolChoice(value: ToolChoiceConfig | undefined): ToolChoiceConfig {\n  const normalizedMode =\n    value?.mode === \"auto\" || value?.mode === \"none\" || value?.mode === \"required\"\n      ? value.mode\n      : \"auto\";\n  const normalizedMax = normalizeMaxToolCalls(value?.maxToolCalls);\n\n  return {\n    mode: normalizedMode,\n    ...(normalizedMax !== undefined ? { maxToolCalls: normalizedMax } : {}),\n  } satisfies ToolChoiceConfig;\n}\n\nexport function applyModelSafety(config: ModelSafetyConfig = {}): ModelSafetyResult {\n  const safeMode = isSafeModeEnabled();\n  const temperature = normalizeTemperature(config.temperature);\n  const topP = normalizeTopP(config.topP);\n  const toolChoiceConfig = normalizeToolChoice(config.toolChoice);\n\n  const safeTemperature = safeMode\n    ? Math.min(temperature, SAFE_MODE_TEMPERATURE_CEILING)\n    : temperature;\n\n  const safeToolMax = safeMode\n    ? Math.min(\n        toolChoiceConfig.maxToolCalls ?? SAFE_MODE_MAX_TOOL_CALLS,\n        SAFE_MODE_MAX_TOOL_CALLS,\n      )\n    : toolChoiceConfig.maxToolCalls;\n\n  const toolChoice: ToolChoiceConfig = safeMode\n    ? {\n        mode: toolChoiceConfig.mode === \"none\" ? \"none\" : \"auto\",\n        ...(safeToolMax !== undefined ? { maxToolCalls: safeToolMax } : {}),\n      }\n    : {\n        mode: toolChoiceConfig.mode,\n        ...(safeToolMax !== undefined ? { maxToolCalls: safeToolMax } : {}),\n      };\n\n  return {\n    temperature: safeTemperature,\n    ...(topP !== undefined ? { topP } : {}),\n    toolChoice,\n    safeMode,\n  } satisfies ModelSafetyResult;\n}\n\nexport interface StreamingAbortController {\n  readonly signal: AbortSignal;\n  abort(reason?: unknown): void;\n  onAbort(listener: (reason: unknown) => void): () => void;\n  throwIfAborted(): void;\n}\n\nexport function createStreamingAbortController(\n  parentSignal?: AbortSignal,\n): StreamingAbortController {\n  const controller = new AbortController();\n  const listeners = new Set<(reason: unknown) => void>();\n\n  const notify = () => {\n    const reason = controller.signal.reason;\n    for (const listener of Array.from(listeners)) {\n      listener(reason);\n    }\n    listeners.clear();\n  };\n\n  controller.signal.addEventListener(\"abort\", notify, { once: true });\n\n  if (parentSignal) {\n    if (parentSignal.aborted) {\n      controller.abort(parentSignal.reason);\n    } else {\n      const handleParentAbort = () => {\n        controller.abort(parentSignal.reason);\n      };\n      parentSignal.addEventListener(\"abort\", handleParentAbort, { once: true });\n      controller.signal.addEventListener(\n        \"abort\",\n        () => parentSignal.removeEventListener(\"abort\", handleParentAbort),\n        { once: true },\n      );\n    }\n  }\n\n  return {\n    signal: controller.signal,\n    abort(reason?: unknown) {\n      if (!controller.signal.aborted) {\n        controller.abort(reason ?? new Error(\"Stream aborted\"));\n      }\n    },\n    onAbort(listener: (reason: unknown) => void) {\n      listeners.add(listener);\n      if (controller.signal.aborted) {\n        listener(controller.signal.reason);\n        listeners.delete(listener);\n        return () => undefined;\n      }\n      return () => {\n        listeners.delete(listener);\n      };\n    },\n    throwIfAborted() {\n      if (controller.signal.aborted) {\n        throw controller.signal.reason ?? new Error(\"Stream aborted\");\n      }\n    },\n  };\n}\n\nexport function linkAbortSignals(target: AbortController, ...sources: AbortSignal[]): () => void {\n  const removers: Array<() => void> = [];\n\n  for (const signal of sources) {\n    if (signal.aborted) {\n      target.abort(signal.reason);\n      continue;\n    }\n\n    const propagateAbort = () => {\n      target.abort(signal.reason);\n    };\n\n    const handleTargetAbort = () => {\n      signal.removeEventListener(\"abort\", propagateAbort);\n      target.signal.removeEventListener(\"abort\", handleTargetAbort);\n    };\n\n    signal.addEventListener(\"abort\", propagateAbort, { once: true });\n    target.signal.addEventListener(\"abort\", handleTargetAbort, { once: true });\n\n    removers.push(() => {\n      signal.removeEventListener(\"abort\", propagateAbort);\n      target.signal.removeEventListener(\"abort\", handleTargetAbort);\n    });\n  }\n\n  return () => {\n    for (const remove of removers) {\n      remove();\n    }\n  };\n}\n","import { z } from \"zod\";\n\nimport {\n  applyModelSafety,\n  enforceTokenBudget,\n  guardResponse,\n  sanitizePrompt,\n  type TokenBudgetContent,\n} from \"@/ai/safety\";\nimport type { ISODate } from \"@/components/planner\";\nimport {\n  parsePlannerPhrase,\n  summariseParse,\n  type PlannerParseConfidence,\n} from \"@/lib/scheduling\";\nimport { type LlmAgentMetadata } from \"@/lib/metrics/llmTokens\";\n\nconst SYSTEM_PROMPT = [\n  \"You are Planner, an assistant that helps people organise projects and daily tasks.\",\n  \"Extract actionable planner suggestions from the user's description and keep responses concise.\",\n  \"Prioritise clear wording and surface any detected dates, times, or recurring patterns.\",\n].join(\"\\n\");\n\nconst DEFAULT_MAX_TOKENS = 4_000;\nconst DEFAULT_RESPONSE_RESERVE = 512;\nconst SAFE_MODE_SUGGESTION_LIMIT = 3;\nconst DEFAULT_SUGGESTION_LIMIT = 5;\n\nconst ENABLED_FLAG_VALUES = new Set([\"1\", \"true\", \"on\", \"yes\"]);\n\nconst AGENT_METADATA: LlmAgentMetadata = {\n  id: \"planner.assistant\",\n  label: \"Planner Assistant\",\n  kind: \"planner\",\n};\n\nconst plannerAssistantSuggestionSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  intent: z.union([z.literal(\"task\"), z.literal(\"project\")]),\n  confidence: z.union([\n    z.literal(\"none\"),\n    z.literal(\"low\"),\n    z.literal(\"medium\"),\n    z.literal(\"high\"),\n  ]),\n  summary: z.string().nullable(),\n  schedule: z\n    .object({\n      date: z.string().optional(),\n      time: z.string().optional(),\n    })\n    .optional(),\n});\n\nconst plannerAssistantPlanSchema = z.object({\n  sanitizedPrompt: z.string(),\n  prompt: z.string(),\n  summary: z.string().nullable(),\n  suggestions: z.array(plannerAssistantSuggestionSchema),\n  safety: z.object({\n    safeMode: z.boolean(),\n    temperature: z.number(),\n    toolChoice: z.object({\n      mode: z.union([z.literal(\"auto\"), z.literal(\"none\"), z.literal(\"required\")]),\n      maxToolCalls: z.number().int().nonnegative().optional(),\n    }),\n    topP: z.number().optional(),\n  }),\n  tokenBudget: z.object({\n    totalTokens: z.number().int().nonnegative(),\n    availableTokens: z.number().int().nonnegative(),\n    removedCount: z.number().int().nonnegative(),\n  }),\n});\n\nexport type PlannerAssistantSuggestion = z.infer<\n  typeof plannerAssistantSuggestionSchema\n>;\nexport type PlannerAssistantPlan = z.infer<typeof plannerAssistantPlanSchema>;\n\nexport const plannerAssistantSuggestionValidator =\n  plannerAssistantSuggestionSchema;\nexport const plannerAssistantPlanValidator = plannerAssistantPlanSchema;\n\ntype PlannerAgentMessage = TokenBudgetContent & { role: \"system\" | \"user\" };\n\ntype PlannerAssistantIntent = \"task\" | \"project\";\n\nexport type PlannerAssistantOptions = {\n  readonly prompt: string;\n  readonly now?: Date;\n  readonly maxTokens?: number;\n  readonly reservedForResponse?: number;\n  readonly suggestionLimit?: number;\n};\n\nexport type PlannerAssistantErrorCode =\n  | \"empty_prompt\"\n  | \"budget_exhausted\"\n  | \"invalid_plan\";\n\nexport class PlannerAssistantError extends Error {\n  readonly code: PlannerAssistantErrorCode;\n\n  constructor(code: PlannerAssistantErrorCode, message: string) {\n    super(message);\n    this.code = code;\n    this.name = \"PlannerAssistantError\";\n  }\n}\n\nfunction isSafeModeFlagEnabled(value: string | undefined): boolean {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n\n  const normalized = value.trim().toLowerCase();\n  if (!normalized) {\n    return false;\n  }\n\n  return ENABLED_FLAG_VALUES.has(normalized);\n}\n\nfunction createMessages(prompt: string): PlannerAgentMessage[] {\n  return [\n    {\n      role: \"system\",\n      content: SYSTEM_PROMPT,\n      pinned: true,\n    },\n    {\n      role: \"user\",\n      content: prompt,\n    },\n  ];\n}\n\nfunction extractUserPrompt(messages: readonly PlannerAgentMessage[]): string {\n  const userMessage = [...messages]\n    .reverse()\n    .find((message) => message.role === \"user\" && message.content.trim().length > 0);\n\n  return userMessage ? userMessage.content.trim() : \"\";\n}\n\nfunction splitSegments(input: string): string[] {\n  const trimmed = input.trim();\n  if (!trimmed) {\n    return [];\n  }\n\n  const segments = new Set<string>();\n  segments.add(trimmed);\n\n  const candidateLines = trimmed\n    .split(/\\n+/)\n    .map((line) => line.replace(/^[-*•\\u2022]\\s*/, \"\").trim())\n    .filter((line) => line.length > 0);\n\n  for (const line of candidateLines) {\n    segments.add(line);\n  }\n\n  return Array.from(segments);\n}\n\nfunction toSuggestionId(index: number, title: string): string {\n  const normalized = title\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-+|-+$/g, \"\");\n  if (!normalized) {\n    return `${index}`;\n  }\n  return `${index}-${normalized}`;\n}\n\nfunction toSchedule(\n  date?: ISODate,\n  time?: string,\n): PlannerAssistantSuggestion[\"schedule\"] {\n  if (!date && !time) {\n    return undefined;\n  }\n\n  return {\n    ...(date ? { date } : {}),\n    ...(time ? { time } : {}),\n  };\n}\n\nfunction synthesiseSuggestion(\n  text: string,\n  now: Date,\n  index: number,\n): PlannerAssistantSuggestion {\n  const parsed = parsePlannerPhrase(text, { now });\n  const title = parsed.event.title.trim() || text;\n  const summary = summariseParse(parsed);\n  const schedule = toSchedule(parsed.event.startDate, parsed.event.time);\n\n  return {\n    id: toSuggestionId(index, `${title}-${schedule?.date ?? \"\"}-${schedule?.time ?? \"\"}`),\n    title,\n    intent: parsed.intent as PlannerAssistantIntent,\n    confidence: parsed.confidence,\n    summary: summary.length > 0 ? summary : null,\n    ...(schedule ? { schedule } : {}),\n  } satisfies PlannerAssistantSuggestion;\n}\n\nfunction deduplicateSuggestions(\n  suggestions: PlannerAssistantSuggestion[],\n): PlannerAssistantSuggestion[] {\n  const seen = new Set<string>();\n  const result: PlannerAssistantSuggestion[] = [];\n\n  for (const suggestion of suggestions) {\n    const key = [\n      suggestion.intent,\n      suggestion.title.toLowerCase(),\n      suggestion.schedule?.date ?? \"\",\n      suggestion.schedule?.time ?? \"\",\n    ].join(\"|\");\n\n    if (seen.has(key)) {\n      continue;\n    }\n\n    seen.add(key);\n    result.push(suggestion);\n  }\n\n  return result;\n}\n\nexport function planWithAssistant(\n  options: PlannerAssistantOptions,\n): PlannerAssistantPlan {\n  const displayPrompt = sanitizePrompt(options.prompt, { allowMarkup: true });\n  if (!displayPrompt) {\n    throw new PlannerAssistantError(\n      \"empty_prompt\",\n      \"The planner assistant requires a non-empty prompt.\",\n    );\n  }\n\n  const sanitizedPrompt = sanitizePrompt(options.prompt);\n\n  const safety = applyModelSafety();\n  const safeModeEnabled =\n    safety.safeMode && isSafeModeFlagEnabled(process.env.SAFE_MODE);\n\n  const messages = createMessages(displayPrompt);\n  const budget = enforceTokenBudget(messages, {\n    maxTokens: options.maxTokens ?? DEFAULT_MAX_TOKENS,\n    reservedForResponse: options.reservedForResponse ?? DEFAULT_RESPONSE_RESERVE,\n    agent: AGENT_METADATA,\n  });\n\n  const finalPrompt = extractUserPrompt(budget.messages);\n  if (!finalPrompt) {\n    throw new PlannerAssistantError(\n      \"budget_exhausted\",\n      \"The planner assistant could not keep the user's prompt within the token budget.\",\n    );\n  }\n\n  const segments = splitSegments(finalPrompt);\n  const now = options.now ?? new Date();\n  const requestedLimit =\n    options.suggestionLimit ??\n    (safeModeEnabled ? SAFE_MODE_SUGGESTION_LIMIT : DEFAULT_SUGGESTION_LIMIT);\n\n  const limit = Math.max(\n    1,\n    safeModeEnabled\n      ? Math.min(requestedLimit, SAFE_MODE_SUGGESTION_LIMIT)\n      : requestedLimit,\n  );\n\n  const rawSuggestions = segments\n    .slice(0, limit * 2)\n    .map((segment, index) => synthesiseSuggestion(segment, now, index));\n  const suggestions = deduplicateSuggestions(rawSuggestions).slice(0, limit);\n\n  if (!suggestions.length) {\n    suggestions.push(\n      {\n        id: toSuggestionId(0, finalPrompt),\n        title: finalPrompt,\n        intent: \"task\",\n        confidence: \"none\" satisfies PlannerParseConfidence,\n        summary: null,\n      },\n    );\n  }\n\n  const summary = suggestions[0]?.summary ?? null;\n  const prompt = [SYSTEM_PROMPT, \"\", finalPrompt].join(\"\\n\");\n\n  const plan = {\n    sanitizedPrompt,\n    prompt,\n    summary,\n    suggestions,\n    safety: {\n      ...safety,\n      safeMode: safeModeEnabled,\n    },\n    tokenBudget: {\n      totalTokens: budget.totalTokens,\n      availableTokens: budget.availableTokens,\n      removedCount: budget.removedCount,\n    },\n  } satisfies PlannerAssistantPlan;\n\n  const validation = guardResponse(plan, plannerAssistantPlanSchema, {\n    label: \"planner assistant plan\",\n  });\n\n  if (!validation.success) {\n    throw new PlannerAssistantError(\n      \"invalid_plan\",\n      \"Planner assistant produced an invalid plan.\",\n    );\n  }\n\n  return validation.data;\n}\n","import { SAFE_MODE_FALLBACK } from '@env'\n\nconst ENABLED_FLAG_VALUES = new Set(['1', 'true', 'on', 'yes'])\nconst DISABLED_FLAG_VALUES = new Set(['0', 'false', 'off', 'no'])\n\nfunction normalizeFlag(value: string | undefined | null): boolean | null {\n  if (typeof value !== 'string') {\n    return null\n  }\n\n  const normalized = value.trim().toLowerCase()\n  if (!normalized) {\n    return null\n  }\n\n  if (ENABLED_FLAG_VALUES.has(normalized)) {\n    return true\n  }\n\n  if (DISABLED_FLAG_VALUES.has(normalized)) {\n    return false\n  }\n\n  return null\n}\n\nfunction resolveFlag(\n  primary: string | undefined,\n  secondary: string | undefined,\n): boolean {\n  return (\n    normalizeFlag(primary) ??\n    normalizeFlag(secondary) ??\n    normalizeFlag(SAFE_MODE_FALLBACK) ??\n    false\n  )\n}\n\nexport type PlannerAssistantSafeModeState = {\n  readonly server: boolean\n  readonly client: boolean\n  readonly active: boolean\n}\n\ntype PlannerAssistantSafeModeEnv = {\n  readonly SAFE_MODE?: string\n  readonly NEXT_PUBLIC_SAFE_MODE?: string\n  readonly [key: string]: string | undefined\n}\n\nexport function resolvePlannerAssistantSafeMode(\n  env: PlannerAssistantSafeModeEnv = process.env,\n): PlannerAssistantSafeModeState {\n  const server = resolveFlag(env.SAFE_MODE, env.NEXT_PUBLIC_SAFE_MODE)\n  const client = resolveFlag(env.NEXT_PUBLIC_SAFE_MODE, env.SAFE_MODE)\n\n  return {\n    server,\n    client,\n    active: server && client,\n  }\n}\n","import { z } from 'zod'\n\nimport { fromISODate } from '@/lib/date'\nimport {\n  PlannerAssistantError,\n  plannerAssistantPlanValidator,\n  planWithAssistant,\n} from '@/lib/assistant/plannerAgent'\nimport {\n  resolvePlannerAssistantSafeMode,\n  type PlannerAssistantSafeModeState,\n} from '@/lib/assistant/safe-mode'\n\nexport const plannerAssistantRequestSchema = z.object({\n  prompt: z.string(),\n  focusDate: z.string().optional(),\n  suggestionLimit: z.number().int().positive().max(10).optional(),\n})\n\nexport type PlannerAssistantActionInput = z.input<\n  typeof plannerAssistantRequestSchema\n>\n\nexport type PlannerAssistantActionSuccess = {\n  ok: true\n  plan: z.infer<typeof plannerAssistantPlanValidator>\n  safeMode: PlannerAssistantSafeModeState\n}\n\nexport type PlannerAssistantActionError = {\n  ok: false\n  error: string\n  message: string\n  safeMode: PlannerAssistantSafeModeState\n  issues?: unknown\n}\n\nexport type PlannerAssistantActionResult =\n  | PlannerAssistantActionSuccess\n  | PlannerAssistantActionError\n\nfunction formatValidationIssues(\n  issues: z.ZodIssue[],\n): Array<{ path: z.ZodIssue['path']; message: string }> {\n  return issues.map((issue) => ({\n    path: issue.path,\n    message: issue.message,\n  }))\n}\n\nexport async function planWithAssistantAction(\n  input: PlannerAssistantActionInput,\n): Promise<PlannerAssistantActionResult> {\n  const safeMode = resolvePlannerAssistantSafeMode()\n\n  if (safeMode.server !== safeMode.client) {\n    return {\n      ok: false,\n      error: 'safe_mode_mismatch',\n      message:\n        'Planner assistant is disabled because SAFE_MODE and NEXT_PUBLIC_SAFE_MODE do not match.',\n      safeMode,\n    } satisfies PlannerAssistantActionError\n  }\n\n  const parsed = plannerAssistantRequestSchema.safeParse(input)\n  if (!parsed.success) {\n    return {\n      ok: false,\n      error: 'invalid_request',\n      message: 'Invalid planner assistant request.',\n      safeMode,\n      issues: formatValidationIssues(parsed.error.issues),\n    } satisfies PlannerAssistantActionError\n  }\n\n  try {\n    const { prompt, focusDate, suggestionLimit } = parsed.data\n    const now = focusDate ? fromISODate(focusDate) ?? undefined : undefined\n    const plan = planWithAssistant({\n      prompt,\n      now,\n      suggestionLimit,\n    })\n\n    return {\n      ok: true,\n      plan,\n      safeMode,\n    } satisfies PlannerAssistantActionSuccess\n  } catch (error) {\n    if (error instanceof PlannerAssistantError) {\n      if (error.code === 'empty_prompt') {\n        return {\n          ok: false,\n          error: error.code,\n          message: 'Describe your plan before asking the assistant.',\n          safeMode,\n        } satisfies PlannerAssistantActionError\n      }\n\n      if (error.code === 'budget_exhausted') {\n        return {\n          ok: false,\n          error: error.code,\n          message: 'Planner assistant prompt exceeded the token budget.',\n          safeMode,\n        } satisfies PlannerAssistantActionError\n      }\n\n      return {\n        ok: false,\n        error: error.code,\n        message: 'Planner assistant produced an invalid response.',\n        safeMode,\n      } satisfies PlannerAssistantActionError\n    }\n\n    return {\n      ok: false,\n      error: 'internal_error',\n      message:\n        error instanceof Error ? error.message : 'Planner assistant failed.',\n      safeMode,\n    } satisfies PlannerAssistantActionError\n  }\n}\n"],"names":["usageStore","Map","aggregateTokens","normalizeText","value","undefined","trimmed","trim","length","recordLlmTokenUsage","metadata","tokens","existing","normalizedMetadata","incoming","normalizeMetadata","normalizedId","id","normalizedLabel","label","normalizedKind","kind","normalizedTokens","normalizeTokenCount","Number","isFinite","rounded","Math","round","get","previousTokens","delete","mergedMetadata","mergeMetadata","set","cachedSegmenter","CONTROL_CHAR_PATTERN","INVISIBLE_CHAR_PATTERN","COLLAPSE_SPACES_PATTERN","SAFE_MODE_RESPONSE_RESERVE","resolveNumericEnv","min","integer","SAFE_MODE_TEMPERATURE_CEILING","SAFE_MODE_MAX_TOOL_CALLS","warnedMessages","Set","normalizeIssuePath","path","normalized","segment","push","description","toString","normalizeIssueMessage","issue","code","z","invalid_type","message","test","warnOnce","key","console","has","add","warn","reportTokenEstimateIssue","index","raw","reason","printable","JSON","stringify","formatIssuePath","reduce","acc","getUnicodeSegments","input","intlApi","Intl","segmenterCtor","Segmenter","granularity","segmenter","Array","from","ENABLED_FLAG_VALUES","reportNumericEnvIssue","name","names","fallback","options","process","candidates","isArray","env","parsed","trunc","isNaN","getDefaultMaxInputLength","FALLBACK_MAX_INPUT_LENGTH","sanitizePrompt","maxLength","allowMarkup","resolvedMaxLength","max","replace","split","map","line","trimEnd","join","truncated","unicodeTruncate","segments","slice","sanitizeText","defaultTokenEstimator","content","tokensPerCharacter","getDefaultTokensPerCharacter","FALLBACK_TOKENS_PER_CHARACTER","EPSILON","characterCount","unicodeLength","ceil","enforceTokenBudgetInternal","messages","estimator","estimateTokens","incomingReserved","reservedForResponse","reserved","floor","clientSafeMode","isSafeModeEnabled","serverSafeMode","isServerSafeModeExplicitlyEnabled","SAFE_MODE","toLowerCase","safeMode","safeReserved","incomingMaxTokens","maxTokens","availableTokens","safeMaxTokens","getSafeModeTokenCeiling","SAFE_MODE_TOKEN_CEILING_FALLBACK","kept","used","removed","estimate","isInteger","pinned","reverse","result","removedCount","totalTokens","agent","MIN_TOP_P","SYSTEM_PROMPT","AGENT_METADATA","plannerAssistantSuggestionSchema","title","intent","confidence","summary","nullable","schedule","date","optional","time","plannerAssistantPlanSchema","sanitizedPrompt","prompt","suggestions","safety","temperature","toolChoice","mode","maxToolCalls","int","nonnegative","topP","tokenBudget","PlannerAssistantError","Error","toSuggestionId","DISABLED_FLAG_VALUES","normalizeFlag","resolveFlag","primary","secondary","SAFE_MODE_FALLBACK","plannerAssistantRequestSchema","focusDate","suggestionLimit","positive","planWithAssistantAction","resolvePlannerAssistantSafeMode","server","NEXT_PUBLIC_SAFE_MODE","client","active","ok","error","safeParse","success","issues","formatValidationIssues","fromISODate","data","now","plan","planWithAssistant","displayPrompt","applyModelSafety","toolChoiceConfig","config","normalizeTemperature","DEFAULT_TEMPERATURE","clamped","MIN_TEMPERATURE","MAX_TEMPERATURE","normalizeTopP","MAX_TOP_P","normalizeToolChoice","normalizedMode","normalizedMax","normalizeMaxToolCalls","safeTemperature","safeToolMax","safeModeEnabled","isSafeModeFlagEnabled","budget","enforceTokenBudget","restOptions","role","DEFAULT_MAX_TOKENS","finalPrompt","extractUserPrompt","DEFAULT_RESPONSE_RESERVE","userMessage","find","splitSegments","candidateLines","filter","Date","requestedLimit","limit","SAFE_MODE_SUGGESTION_LIMIT","deduplicateSuggestions","DEFAULT_SUGGESTION_LIMIT","seen","rawSuggestions","suggestion","synthesiseSuggestion","parsePlannerPhrase","text","event","summariseParse","toSchedule","startDate","validation","guardResponse","schema","parse","reportSchemaValidationFailure","String","pathText","cause"],"sourceRoot":"","ignoreList":[]}