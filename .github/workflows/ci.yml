name: CI

on:
  pull_request:
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - 'CHANGELOG.md'
  push:
    branches:
      - main
      - work
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - 'CHANGELOG.md'
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  NEXT_TELEMETRY_DISABLED: '1'
  CI: 'true'

jobs:
  install:
    name: Install & cache dependencies
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      node-modules-cache-key: ${{ steps.setup.outputs.node-modules-cache-key }}
      package-manager: ${{ steps.setup.outputs.package-manager }}
    steps:
      - id: setup
        uses: ./.github/actions/setup-node-project
        with:
          cache-node-modules: 'true'
          cache-playwright: 'false'
      - name: Record environment
        run: |
          node --version
          npm --version

  lint:
    name: Lint (Node ${{ matrix.node }})
    needs: install
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    strategy:
      fail-fast: false
      matrix:
        node: ['22.x']
    steps:
      - uses: ./.github/actions/setup-node-project
        with:
          node-version: ${{ matrix.node }}
          cache-node-modules: 'true'
      - name: Prepare report directories
        run: |
          mkdir -p reports/eslint
      - name: Run ESLint
        run: npm run lint:ci
      - name: Emit ESLint annotations
        if: always()
        run: |
          node <<'NODE'
          import fs from 'node:fs';
          import path from 'node:path';
          const reportPath = path.join(process.cwd(), 'reports', 'eslint', 'results.json');
          if (!fs.existsSync(reportPath)) {
            process.exit(0);
          }
          const results = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
          let problems = 0;
          for (const file of results) {
            for (const message of file.messages ?? []) {
              const severity = message.severity === 2 ? 'error' : 'warning';
              const locLine = message.line ?? 1;
              const locColumn = message.column ?? 1;
              const ruleId = message.ruleId ? ` (${message.ruleId})` : '';
              console.log(`::${severity} file=${file.filePath},line=${locLine},col=${locColumn}::${message.message}${ruleId}`);
              problems += 1;
            }
          }
          if (problems === 0) {
            console.log('No ESLint issues detected.');
          }
          NODE
      - name: Run design token guard
        run: npm run lint:design
      - name: Upload ESLint results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: eslint-report-${{ matrix.node }}
          path: reports/eslint

  typecheck:
    name: Typecheck (Node ${{ matrix.node }})
    needs: install
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    strategy:
      fail-fast: false
      matrix:
        node: ['22.x']
    steps:
      - uses: ./.github/actions/setup-node-project
        with:
          node-version: ${{ matrix.node }}
          cache-node-modules: 'true'
      - name: Run TypeScript
        run: |
          mkdir -p reports/typecheck
          npm run typecheck:ci 2>&1 | tee reports/typecheck/output.log
          test ${PIPESTATUS[0]} -eq 0
      - name: Emit TypeScript annotations
        if: always()
        run: |
          node <<'NODE'
          import fs from 'node:fs';
          import path from 'node:path';
          const logPath = path.join(process.cwd(), 'reports', 'typecheck', 'output.log');
          if (!fs.existsSync(logPath)) {
            process.exit(0);
          }
          const lines = fs.readFileSync(logPath, 'utf8').split(/\r?\n/);
          const pattern = /(.*)\((\d+),(\d+)\): error (TS\d+): (.*)/;
          for (const line of lines) {
            const match = line.match(pattern);
            if (match) {
              const [, file, lineNum, colNum, code, message] = match;
              console.log(`::error file=${file},line=${lineNum},col=${colNum}::${message} [${code}]`);
            }
          }
          NODE
      - name: Upload typecheck log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: typecheck-log-${{ matrix.node }}
          path: reports/typecheck

  unit:
    name: Unit tests (Node ${{ matrix.node }})
    needs: install
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    strategy:
      fail-fast: false
      matrix:
        node: ['22.x']
    steps:
      - uses: ./.github/actions/setup-node-project
        with:
          node-version: ${{ matrix.node }}
          cache-node-modules: 'true'
      - name: Run unit tests
        env:
          VITEST_SEGFAULT_RETRY: '1'
        run: |
          mkdir -p reports/unit
          npm run test:ci
      - name: Emit unit test annotations
        if: always()
        run: |
          node <<'NODE'
          import fs from 'node:fs';
          const junitPath = 'reports/unit/junit.xml';
          if (!fs.existsSync(junitPath)) {
            process.exit(0);
          }
          const xml = fs.readFileSync(junitPath, 'utf8');
          const testcasePattern = /<testcase\b([^>]*)>([\s\S]*?)<\/testcase>/g;
          const attrPattern = /(\w+)="([^"]*)"/g;
          const parseAttrs = (fragment) => {
            const attrs = {};
            let match;
            while ((match = attrPattern.exec(fragment))) {
              attrs[match[1]] = match[2];
            }
            return attrs;
          };
          let testcaseMatch;
          while ((testcaseMatch = testcasePattern.exec(xml))) {
            const attrs = parseAttrs(testcaseMatch[1] ?? '');
            const failureMatch = testcaseMatch[2]?.match(/<failure\b([^>]*)>([\s\S]*?)<\/failure>/);
            if (!failureMatch) continue;
            const failureAttrs = parseAttrs(failureMatch[1] ?? '');
            const location = failureAttrs.file ?? attrs.file ?? '';
            const line = failureAttrs.line ?? '1';
            const message = failureAttrs.message ?? failureMatch[2]?.trim() ?? 'Test failure';
            const filePart = location ? `file=${location},` : '';
            console.log(`::error ${filePart}line=${line}::${attrs.classname ?? 'spec'} :: ${attrs.name ?? 'test'} — ${message}`);
          }
          NODE
      - name: Upload Vitest artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-${{ matrix.node }}
          path: |
            reports/unit
            coverage

  build:
    name: Build
    needs:
      - lint
      - typecheck
      - unit
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: ./.github/actions/setup-node-project
        with:
          cache-node-modules: 'true'
          extra-cache-paths: .next/cache
      - name: Build application
        run: npm run build
      - name: Upload Next.js build
        uses: actions/upload-artifact@v4
        with:
          name: next-build
          path: .next

  e2e:
    name: Playwright ${{ matrix.browser }} shard ${{ matrix.shard }}
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    strategy:
      fail-fast: false
      matrix:
        browser: [chromium, firefox, webkit]
        shard: [1, 2]
    steps:
      - uses: ./.github/actions/setup-node-project
        with:
          cache-node-modules: 'true'
          cache-playwright: 'true'
          install-playwright: 'true'
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: next-build
          path: .next
      - name: Start application server
        id: server
        run: |
          set -euo pipefail
          PORT=3000
          case "${{ matrix.browser }}" in
            chromium) PORT=3000 ;;
            firefox) PORT=3010 ;;
            webkit) PORT=3020 ;;
          esac
          PORT=$((PORT + ( ${{ matrix.shard }} - 1 )))
          echo "port=$PORT" >>"$GITHUB_OUTPUT"
          npm run start -- --hostname 127.0.0.1 --port "$PORT" &
          SERVER_PID=$!
          echo "pid=$SERVER_PID" >>"$GITHUB_OUTPUT"
          for attempt in $(seq 1 30); do
            if curl --fail --silent --head "http://127.0.0.1:${PORT}" >/dev/null; then
              exit 0
            fi
            sleep 2
          done
          echo "Server failed to start" >&2
          exit 1
      - name: Run Playwright tests
        env:
          PLAYWRIGHT_TEST_BASE_URL: http://127.0.0.1:${{ steps.server.outputs.port }}
          AXE_REPORT_DIR: playwright-report/axe/${{ matrix.browser }}-${{ matrix.shard }}
        run: |
          set -euo pipefail
          mkdir -p reports/e2e/${{ matrix.browser }}
          npx playwright test \
            --project=${{ matrix.browser }} \
            --shard=${{ matrix.shard }}/2 \
            --reporter=line \
            --reporter=junit=reports/e2e/${{ matrix.browser }}/junit-${{ matrix.shard }}.xml \
            --reporter=html \
            --output=playwright-report/${{ matrix.browser }}-${{ matrix.shard }}
      - name: Emit Playwright annotations
        if: always()
        run: |
          node <<'NODE'
          import fs from 'node:fs';
          const junitPath = `reports/e2e/${process.env.BROWSER}/junit-${process.env.SHARD}.xml`;
          if (!fs.existsSync(junitPath)) {
            process.exit(0);
          }
          const xml = fs.readFileSync(junitPath, 'utf8');
          const testcasePattern = /<testcase\b([^>]*)>([\s\S]*?)<\/testcase>/g;
          const attrPattern = /(\w+)="([^"]*)"/g;
          const parseAttrs = (fragment) => {
            const attrs = {};
            let match;
            while ((match = attrPattern.exec(fragment))) {
              attrs[match[1]] = match[2];
            }
            return attrs;
          };
          let testcaseMatch;
          while ((testcaseMatch = testcasePattern.exec(xml))) {
            const attrs = parseAttrs(testcaseMatch[1] ?? '');
            const failureMatch = testcaseMatch[2]?.match(/<failure\b([^>]*)>([\s\S]*?)<\/failure>/);
            if (!failureMatch) continue;
            const failureAttrs = parseAttrs(failureMatch[1] ?? '');
            const message = failureAttrs.message ?? failureMatch[2]?.trim() ?? 'Test failure';
            console.log(`::error ::${attrs.classname ?? 'playwright'} :: ${attrs.name ?? 'scenario'} — ${message}`);
          }
          NODE
        env:
          BROWSER: ${{ matrix.browser }}
          SHARD: ${{ matrix.shard }}
      - name: Stop application server
        if: always()
        run: |
          if [ -n "${{ steps.server.outputs.pid }}" ]; then
            kill ${{ steps.server.outputs.pid }} || true
            wait ${{ steps.server.outputs.pid }} || true
          fi
      - name: Upload Playwright artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-${{ matrix.browser }}-${{ matrix.shard }}
          path: |
            reports/e2e/${{ matrix.browser }}
            playwright-report/${{ matrix.browser }}-${{ matrix.shard }}

  report:
    name: PR summary
    needs:
      - lint
      - typecheck
      - unit
      - e2e
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: ./.github/actions/setup-node-project
        with:
          cache-node-modules: 'true'
      - name: Download coverage
        uses: actions/download-artifact@v4
        with:
          name: unit-22.x
          path: artifacts/unit
      - name: Download e2e reports
        uses: actions/download-artifact@v4
        with:
          pattern: playwright-*
          path: artifacts/playwright
          merge-multiple: true
      - name: Compose summary
        id: summary
        run: |
          npm run report:summary -- --coverage artifacts/unit/coverage/coverage-summary.json --reports artifacts --output summary.txt
          {
            echo 'body<<EOF'
            cat summary.txt
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
      - name: Post comment
        uses: actions/github-script@v7
        with:
          script: |
            const body = `### CI summary\n${process.env.BODY}\n`;
            const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
              per_page: 100,
            });
            const formatDuration = (start, end) => {
              if (!start || !end) return 'n/a';
              const delta = (new Date(end).getTime() - new Date(start).getTime()) / 1000;
              const minutes = Math.floor(delta / 60);
              const seconds = Math.round(delta % 60);
              return minutes ? `${minutes}m ${seconds}s` : `${seconds}s`;
            };
            const timingsList = jobsResponse.data.jobs
              .filter((job) => ['Install & cache dependencies', 'Lint (Node 22.x)', 'Typecheck (Node 22.x)', 'Unit tests (Node 22.x)', 'Build', 'Playwright chromium shard 1', 'Playwright chromium shard 2', 'Playwright firefox shard 1', 'Playwright firefox shard 2', 'Playwright webkit shard 1', 'Playwright webkit shard 2'].includes(job.name))
              .map((job) => `- ${job.name}: ${formatDuration(job.started_at, job.completed_at)}`)
              .filter(Boolean);
            const timings = timingsList.length ? timingsList.join('\n') : 'No timing data available';
            const failureCount = (process.env.BODY.match(/• /g) || []).length - 1;
            const flakeRate = failureCount <= 0 ? '0%' : 'n/a (failures present)';
            const summaryBlock = `${body}\n**Job timings**\n${timings}\n\n**Flake rate:** ${flakeRate}`;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const marker = '<!-- ci-summary -->';
            const existing = comments.find((comment) => comment.body?.includes(marker));
            const payload = `${marker}\n${summaryBlock}`;
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: payload,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: payload,
              });
            }
        env:
          BODY: ${{ steps.summary.outputs.body }}

