import "./check-node-version.js";
import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";
import fg from "fast-glob";
import { MultiBar, Presets } from "cli-progress";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, "..");

const featureDirs = [
  path.resolve(__dirname, "../src/components/planner"),
  path.resolve(__dirname, "../src/components/prompts"),
];

const cacheDir = path.join(__dirname, ".cache");
const manifestFile = path.join(cacheDir, "generate-feature-index.json");

type ManifestEntry = { mtimeMs: number; name?: string; lines: string[] };
type Manifest = Record<string, ManifestEntry>;

async function loadManifest(): Promise<Manifest> {
  try {
    const data = await fs.readFile(manifestFile, "utf8");
    return JSON.parse(data) as Manifest;
  } catch {
    return {};
  }
}

async function saveManifest(manifest: Manifest) {
  await fs.mkdir(cacheDir, { recursive: true });
  await fs.writeFile(manifestFile, JSON.stringify(manifest, null, 2));
}

function toExportName(file: string): string {
  const base = path.basename(file).replace(/\.(tsx|ts)$/, "");
  const sanitized = base
    .replace(/[^A-Za-z0-9]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ""))
    .replace(/^(.)/, (c) => c.toUpperCase());
  return sanitized;
}

type ExportInfo = { name?: string; lines: string[] };

async function buildExport(file: string, baseDir: string): Promise<ExportInfo> {
  const rel =
    "./" +
    path
      .relative(baseDir, file)
      .replace(/\\/g, "/")
      .replace(/\.(tsx|ts)$/, "");
  const content = await fs.readFile(file, "utf8");
  const hasDefault = /export\s+default/.test(content);
  const hasNamed =
    /export\s+(?:const|function|class|type|interface|enum|\{)/.test(content);
  const lines: string[] = [];
  let name: string | undefined;
  if (hasDefault) {
    name = toExportName(file);
    lines.push(`export { default as ${name} } from "${rel}";`);
  }
  if (hasNamed) {
    lines.push(`export * from "${rel}";`);
  }
  return { name, lines };
}

async function generate(
  dir: string,
  bar: ReturnType<MultiBar["create"]>,
  manifest: Manifest,
  nextManifest: Manifest,
) {
  const files = await fg(["**/*.{ts,tsx}", "!**/index.ts", "!**/index.tsx"], {
    cwd: dir,
    absolute: true,
  });
  const indexFile = path.join(dir, "index.ts");
  const exports = [
    "// Auto-generated by scripts/generate-feature-index.ts",
    "// Do not edit directly.",
  ];
  const used = new Set<string>();
  const sortedFiles = files.sort((a, b) => {
    const aRel = path.relative(dir, a).replace(/\\/g, "/");
    const bRel = path.relative(dir, b).replace(/\\/g, "/");
    const aIsGallery = /\.gallery\.(tsx|ts)$/.test(aRel);
    const bIsGallery = /\.gallery\.(tsx|ts)$/.test(bRel);
    if (aIsGallery !== bIsGallery) {
      return aIsGallery ? 1 : -1;
    }
    return aRel.localeCompare(bRel);
  });
  for (const file of sortedFiles) {
    const rel = path.relative(rootDir, file).replace(/\\/g, "/");
    const stat = await fs.stat(file);
    let info = manifest[rel];
    if (!info || info.mtimeMs !== stat.mtimeMs) {
      const built = await buildExport(file, dir);
      info = { mtimeMs: stat.mtimeMs, ...built };
    }
    bar.increment();
    if (info.name && used.has(info.name)) {
      nextManifest[rel] = info;
      continue;
    }
    if (info.name) {
      used.add(info.name);
    }
    exports.push(...info.lines);
    nextManifest[rel] = info;
  }
  exports.push("");
  await fs.writeFile(indexFile, exports.join("\n"));
  console.log(`Generated ${path.relative(process.cwd(), indexFile)}`);
}

async function main() {
  const manifest = await loadManifest();
  const nextManifest: Manifest = {};
  const bars = new MultiBar(
    { clearOnComplete: false, hideCursor: true },
    Presets.shades_grey,
  );
  const fileCounts = await Promise.all(
    featureDirs.map((dir) =>
      fg(["**/*.{ts,tsx}", "!**/index.ts", "!**/index.tsx"], {
        cwd: dir,
        absolute: true,
      }).then((f) => f.length),
    ),
  );
  const barsForDirs = featureDirs.map((_, i) => bars.create(fileCounts[i], 0));
  await Promise.all(
    featureDirs.map((dir, i) =>
      generate(dir, barsForDirs[i], manifest, nextManifest),
    ),
  );
  bars.stop();
  await saveManifest(nextManifest);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
