import "./check-node-version.js";
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import postcss from "postcss";
import postcssImport from "postcss-import";
import { rootVariables, themes } from "./themes.ts";
import type { ThemeDefinition, VariableDefinition } from "./themes.ts";
import type { Declaration, Root, Rule } from "postcss";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");
const outputPath = path.join(projectRoot, "app/themes.css");
const staticPath = path.join(__dirname, "themes-static.css");

const HEADER = [
  "/* Auto-generated by scripts/generate-themes.ts */",
  "/* Do not edit directly. */",
  "",
  "/* =========================================================",
  "   Theme tokens + per-theme glitch backdrops",
  "   ========================================================= */",
  "",
  '@import "../../tokens/tokens.css";',
].join("\n");

const SUPPORTS_SECTION = String.raw`/* Upgrade tokens when color-mix(oklab) is supported */
@supports (color: color-mix(in oklab, white, black)) {
  :root {
    --accent-overlay: color-mix(in oklab, hsl(var(--accent)) 60%, transparent);
    --ring-contrast: color-mix(
      in oklab,
      hsl(var(--ring)) 70%,
      hsl(var(--background)) 30%
    );
    --glow-active: color-mix(in oklab, hsl(var(--glow)) 50%, transparent);
    --glow-primary: color-mix(in oklab, hsl(var(--primary)) 58%, transparent);
    --neon-soft: color-mix(in oklab, hsl(var(--neon)) 50%, transparent);
    --card-hairline: color-mix(
      in oklab,
      hsl(var(--border)) 82%,
      hsl(var(--accent)) 18%
    );
    --blob-surface-1: color-mix(
      in oklab,
      hsl(var(--surface)) 72%,
      hsl(var(--accent)) 28%
    );
    --blob-surface-2: color-mix(
      in oklab,
      hsl(var(--surface-2)) 68%,
      hsl(var(--accent-2)) 32%
    );
    --blob-surface-3: color-mix(
      in oklab,
      hsl(var(--card)) 70%,
      hsl(var(--ring)) 30%
    );
    --blob-surface-shadow: color-mix(
      in oklab,
      hsl(var(--shadow-color)) 68%,
      hsl(var(--background)) 32%
    );
    --aurora-g-light: color-mix(in oklab, hsl(var(--accent-2)) 37.5%, white);
    --aurora-g-light-color: var(--aurora-g-light);
    --aurora-p-light: color-mix(in oklab, hsl(var(--accent)) 37.5%, white);
    --aurora-p-light-color: var(--aurora-p-light);
  }
  html.theme-aurora {
    --aurora-g-light: color-mix(in oklab, hsl(var(--accent-2)) 37.5%, white);
    --aurora-g-light-color: var(--aurora-g-light);
    --aurora-p-light: color-mix(in oklab, hsl(var(--accent)) 37.5%, white);
    --aurora-p-light-color: var(--aurora-p-light);
  }
  html.theme-hardstuck {
    --blob-surface-1: color-mix(
      in oklab,
      hsl(var(--surface)) 62%,
      hsl(var(--hardstuck-foreground)) 38%
    );
    --blob-surface-2: color-mix(
      in oklab,
      hsl(var(--surface-2)) 58%,
      hsl(var(--hardstuck-foreground)) 42%
    );
    --blob-surface-3: color-mix(
      in oklab,
      hsl(var(--card)) 60%,
      hsl(var(--ring)) 40%
    );
    --blob-surface-shadow: color-mix(
      in oklab,
      hsl(var(--shadow-color)) 64%,
      hsl(var(--background)) 36%
    );
    --glow-primary: color-mix(in oklab, hsl(var(--ring)) 52%, transparent);
  }
  html.theme-noir {
    --blob-surface-1: color-mix(
      in oklab,
      hsl(var(--surface)) 66%,
      hsl(var(--foreground)) 34%
    );
    --blob-surface-2: color-mix(
      in oklab,
      hsl(var(--surface-2)) 60%,
      hsl(var(--foreground)) 40%
    );
    --blob-surface-3: color-mix(
      in oklab,
      hsl(var(--card)) 64%,
      hsl(var(--accent)) 36%
    );
    --blob-surface-shadow: color-mix(
      in oklab,
      hsl(var(--shadow-color)) 66%,
      hsl(var(--background)) 34%
    );
    --glow-primary: color-mix(in oklab, hsl(var(--ring)) 56%, transparent);
  }
}

/* Upgrade contrast token when color-contrast is supported */
@supports (color: color-contrast(white vs black)) {
  :root {
    --text-on-accent: color-contrast(
      var(--accent-overlay) vs hsl(var(--foreground)),
      hsl(var(--background))
    );
    --success-foreground: color-contrast(
      var(--state-success-surface) vs hsl(var(--foreground)),
      hsl(var(--background))
    );
    --warning-foreground: color-contrast(
      var(--state-warning-surface) vs hsl(var(--foreground)),
      hsl(var(--background))
    );
    --danger-foreground: color-contrast(
      var(--state-danger-surface) vs hsl(var(--foreground)),
      hsl(var(--background))
    );
  }
}

/* Retina half-pixel hairlines when available */
@supports (border: 0.5px solid transparent) {
  :root {
    --hairline-w: 0.5px;
  }
}`;

function ensureSemicolon(value: string): string {
  return value.trimEnd().endsWith(";") ? value : `${value};`;
}

function renderVariableDefinition(
  variable: VariableDefinition,
  indent = 2,
): string {
  const { name, value, comment } = variable;
  const baseIndent = " ".repeat(indent);
  const lines: string[] = [];

  if (comment) {
    const comments = Array.isArray(comment) ? comment : [comment];
    for (const entry of comments) {
      lines.push(`${baseIndent}/* ${entry} */`);
    }
  }

  if (typeof value === "string") {
    lines.push(`${baseIndent}--${name}: ${ensureSemicolon(value)}`);
    return lines.join("\n");
  }

  const values = [...value];
  const hasLeadingEmpty = values[0] === "";
  if (hasLeadingEmpty) {
    values.shift();
  }

  if (!hasLeadingEmpty && values.length === 1) {
    lines.push(`${baseIndent}--${name}: ${ensureSemicolon(values[0] ?? "")}`);
    return lines.join("\n");
  }

  const innerIndent = `${baseIndent}  `;
  const variableLines: string[] = [];

  if (hasLeadingEmpty) {
    variableLines.push(`${baseIndent}--${name}:`);
  } else {
    const first = values.shift();
    if (first !== undefined) {
      variableLines.push(`${baseIndent}--${name}: ${first}`);
    } else {
      variableLines.push(`${baseIndent}--${name}:`);
    }
  }

  values.forEach((line, index) => {
    const isLast = index === values.length - 1;
    const nextIndent = isLast && line.trim() === ")" ? baseIndent : innerIndent;
    const text = isLast ? ensureSemicolon(line) : line;
    variableLines.push(`${nextIndent}${text}`);
  });

  if (values.length === 0) {
    const lastIndex = variableLines.length - 1;
    variableLines[lastIndex] = ensureSemicolon(variableLines[lastIndex]);
  }

  lines.push(...variableLines);
  return lines.join("\n");
}

function renderRootBlock(definitions: VariableDefinition[]): string {
  const lines = [":root {"];
  for (const variable of definitions) {
    lines.push(renderVariableDefinition(variable));
  }
  lines.push("}");
  return lines.join("\n");
}

function dedupeSpacingScale(root: Root): void {
  const spacingNames = new Set(
    Array.from({ length: 8 }, (_, index) => `spacing-${index + 1}`),
  );

  const isRootLevel = (rule: Rule): boolean => rule.parent?.type === "root";

  root.walkRules((rule) => {
    if (rule.selector !== ":root" || !isRootLevel(rule)) {
      return;
    }

    const seen = new Set<string>();
    rule.walkDecls((decl: Declaration) => {
      if (!decl.prop.startsWith("--")) {
        return;
      }
      const name = decl.prop.slice(2);
      if (!spacingNames.has(name)) {
        return;
      }
      if (seen.has(name)) {
        decl.remove();
        return;
      }
      seen.add(name);
    });
  });
}

function renderTheme(theme: ThemeDefinition): string {
  const lines = [
    `/* ---------- ${theme.label} ---------- */`,
    `html.theme-${theme.id} {`,
  ];
  if (theme.description) {
    for (const description of theme.description) {
      lines.push(`  /* ${description} */`);
    }
  }
  for (const variable of theme.variables) {
    lines.push(renderVariableDefinition(variable));
  }
  lines.push("}");
  return lines.join("\n");
}

async function main(): Promise<void> {
  const staticCss = await fs.readFile(staticPath, "utf8");
  const themeBlocks = themes.map(renderTheme).join("\n\n");
  const sections = [
    HEADER,
    renderRootBlock(rootVariables),
    SUPPORTS_SECTION,
    themeBlocks,
    staticCss.trimEnd(),
  ];
  const content = `${sections.join("\n\n")}\n`;
  const processed = await postcss([postcssImport()]).process(content, {
    from: outputPath,
    to: outputPath,
  });
  const finalRoot = processed.root ?? postcss.parse(processed.css);
  dedupeSpacingScale(finalRoot);
  const finalCss = `${finalRoot.toString().trimEnd()}\n`;
  await fs.writeFile(outputPath, finalCss);
  console.log(`Generated ${path.relative(projectRoot, outputPath)}`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
