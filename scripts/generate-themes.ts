import "./check-node-version.js";
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { rootVariables, themes } from "./themes.ts";
import { mixHslWithWhiteInOklab } from "./utils/color.ts";
import type {
  ThemeDefinition,
  TokenValue,
  VariableDefinition,
} from "./themes.ts";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");
const outputPath = path.join(projectRoot, "src/app/themes.css");
const staticPath = path.join(__dirname, "themes-static.css");

const HEADER = [
  "/* Auto-generated by scripts/generate-themes.ts */",
  "/* Do not edit directly. */",
  "",
  "/* =========================================================",
  "   Theme tokens + per-theme glitch backdrops",
  "   ========================================================= */",
  "",
  '@import "../../tokens/tokens.css";',
].join("\n");

const AURORA_LIGHT_RATIO = 0.375;

const SUPPORTS_SECTION = String.raw`/* Upgrade tokens when color-mix(oklab) is supported */
@supports (color: color-mix(in oklab, white, black)) {
  :root {
    --accent-overlay: color-mix(in oklab, hsl(var(--accent)) 60%, transparent);
    --ring-contrast: color-mix(
      in oklab,
      hsl(var(--ring)) 70%,
      hsl(var(--background)) 30%
    );
    --glow-active: color-mix(in oklab, hsl(var(--glow)) 50%, transparent);
    --neon-soft: color-mix(in oklab, hsl(var(--neon)) 50%, transparent);
    --card-hairline: color-mix(
      in oklab,
      hsl(var(--border)) 82%,
      hsl(var(--accent)) 18%
    );
    --aurora-g-light: color-mix(in oklab, hsl(var(--accent-2)) 37.5%, white);
    --aurora-p-light: color-mix(in oklab, hsl(var(--accent)) 37.5%, white);
  }

  html.theme-aurora {
    --aurora-g-light: color-mix(in oklab, hsl(var(--accent-2)) 37.5%, white);
    --aurora-p-light: color-mix(in oklab, hsl(var(--accent)) 37.5%, white);
  }
}

/* Upgrade contrast token when color-contrast is supported */
@supports (color: color-contrast(white vs black)) {
  :root {
    --text-on-accent: color-contrast(
      var(--accent-overlay) vs hsl(var(--foreground)),
      hsl(var(--background))
    );
  }
}

/* Retina half-pixel hairlines when available */
@supports (border: 0.5px solid transparent) {
  :root {
    --hairline-w: 0.5px;
  }
}`;

function ensureSemicolon(value: string): string {
  return value.trimEnd().endsWith(";") ? value : `${value};`;
}

function applyAuroraFallbacks(
  variables: VariableDefinition[],
): VariableDefinition[] {
  const accent = variables.find((variable) => variable.name === "accent");
  const accent2 = variables.find((variable) => variable.name === "accent-2");

  const accentValue =
    typeof accent?.value === "string"
      ? mixHslWithWhiteInOklab(accent.value, AURORA_LIGHT_RATIO)
      : null;
  const accent2Value =
    typeof accent2?.value === "string"
      ? mixHslWithWhiteInOklab(accent2.value, AURORA_LIGHT_RATIO)
      : null;

  if (!accentValue && !accent2Value) {
    return variables;
  }

  return variables.map((variable) => {
    if (variable.name === "aurora-g-light" && accent2Value) {
      return { ...variable, value: accent2Value };
    }

    if (variable.name === "aurora-p-light" && accentValue) {
      return { ...variable, value: accentValue };
    }

    return variable;
  });
}

function renderVariableDefinition(
  name: string,
  tokenValue: TokenValue,
  indent = 2,
): string {
  const baseIndent = " ".repeat(indent);
  if (typeof tokenValue === "string") {
    return `${baseIndent}--${name}: ${ensureSemicolon(tokenValue)}`;
  }

  const values = [...tokenValue];
  const hasLeadingEmpty = values[0] === "";
  if (hasLeadingEmpty) {
    values.shift();
  }

  if (!hasLeadingEmpty && values.length === 1) {
    return `${baseIndent}--${name}: ${ensureSemicolon(values[0] ?? "")}`;
  }

  const lines: string[] = [];
  const innerIndent = `${baseIndent}  `;

  if (hasLeadingEmpty) {
    lines.push(`${baseIndent}--${name}:`);
  } else {
    const first = values.shift();
    if (first !== undefined) {
      lines.push(`${baseIndent}--${name}: ${first}`);
    } else {
      lines.push(`${baseIndent}--${name}:`);
    }
  }

  values.forEach((line, index) => {
    const isLast = index === values.length - 1;
    const nextIndent = isLast && line.trim() === ")" ? baseIndent : innerIndent;
    const text = isLast ? ensureSemicolon(line) : line;
    lines.push(`${nextIndent}${text}`);
  });

  if (values.length === 0) {
    const lastIndex = lines.length - 1;
    lines[lastIndex] = ensureSemicolon(lines[lastIndex]);
  }

  return lines.join("\n");
}

function renderRootBlock(definitions: VariableDefinition[]): string {
  const lines = [":root {"];
  for (const variable of definitions) {
    lines.push(renderVariableDefinition(variable.name, variable.value));
  }
  lines.push("}");
  return lines.join("\n");
}

function renderTheme(theme: ThemeDefinition): string {
  const lines = [
    `/* ---------- ${theme.label} ---------- */`,
    `html.theme-${theme.id} {`,
  ];
  if (theme.description) {
    for (const description of theme.description) {
      lines.push(`  /* ${description} */`);
    }
  }
  const variables = applyAuroraFallbacks(theme.variables);
  for (const variable of variables) {
    lines.push(renderVariableDefinition(variable.name, variable.value));
  }
  lines.push("}");
  return lines.join("\n");
}

async function main(): Promise<void> {
  const staticCss = await fs.readFile(staticPath, "utf8");
  const themeBlocks = themes.map(renderTheme).join("\n\n");
  const sections = [
    HEADER,
    renderRootBlock(rootVariables),
    SUPPORTS_SECTION,
    themeBlocks,
    staticCss.trimEnd(),
  ];
  const content = `${sections.join("\n\n")}\n`;
  await fs.writeFile(outputPath, content);
  console.log(`Generated ${path.relative(projectRoot, outputPath)}`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
