import "./check-node-version.js";
import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";
import fg from "fast-glob";
import { MultiBar, Presets } from "cli-progress";
import pLimit from "p-limit";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const uiDir = path.resolve(__dirname, "../src/components/ui");
const indexFile = path.join(uiDir, "index.ts");
const cacheDir = path.join(__dirname, ".cache");
const manifestFile = path.join(cacheDir, "generate-ui-index.json");

type ManifestEntry = { mtimeMs: number; name?: string; lines: string[] };
type Manifest = Record<string, ManifestEntry>;

async function loadManifest(): Promise<Manifest> {
  try {
    const data = await fs.readFile(manifestFile, "utf8");
    return JSON.parse(data) as Manifest;
  } catch {
    return {};
  }
}

async function saveManifest(manifest: Manifest) {
  await fs.mkdir(cacheDir, { recursive: true });
  await fs.writeFile(manifestFile, JSON.stringify(manifest, null, 2));
}

function toExportName(file: string): string {
  const base = path.basename(file).replace(/\.(tsx|ts)$/, "");
  const sanitized = base
    .replace(/[^A-Za-z0-9]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ""))
    .replace(/^(.)/, (c) => c.toUpperCase());
  return sanitized;
}

type ExportInfo = { name?: string; lines: string[] };

async function buildExport(file: string): Promise<ExportInfo> {
  const rel =
    "./" +
    path
      .relative(uiDir, file)
      .replace(/\\/g, "/")
      .replace(/\.(tsx|ts)$/, "");
  const content = await fs.readFile(file, "utf8");
  const hasDefault = /export\s+default/.test(content);
  const hasNamed =
    /export\s+(?:const|function|class|type|interface|enum|\{)/.test(content);
  const lines: string[] = [];
  let name: string | undefined;
  if (hasDefault) {
    name = toExportName(file);
    lines.push(`export { default as ${name} } from "${rel}";`);
  }
  if (hasNamed) {
    lines.push(`export * from "${rel}";`);
  }
  return { name, lines };
}

async function main() {
  const files = await fg(["**/*.{ts,tsx}", "!**/index.ts", "!**/index.tsx"], {
    cwd: uiDir,
    absolute: true,
  });
  const bars = new MultiBar(
    { clearOnComplete: false, hideCursor: true },
    Presets.shades_grey,
  );
  const bar = bars.create(files.length, 0);
  const manifest = await loadManifest();
  const nextManifest: Manifest = {};
  const exports = [
    "// Auto-generated by scripts/generate-ui-index.ts",
    "// Do not edit directly.",
  ];
  const used = new Set<string>();
  const limit = pLimit(8);
  const sortedFiles = files.sort((a, b) => {
    const aRel = path.relative(uiDir, a).replace(/\\/g, "/");
    const bRel = path.relative(uiDir, b).replace(/\\/g, "/");
    const aIsGallery = /\.gallery\.(tsx|ts)$/.test(aRel);
    const bIsGallery = /\.gallery\.(tsx|ts)$/.test(bRel);
    if (aIsGallery !== bIsGallery) {
      return aIsGallery ? 1 : -1;
    }
    return aRel.localeCompare(bRel);
  });
  const results = await Promise.all(
    sortedFiles.map((file) =>
      limit(async () => {
        const rel = path.relative(uiDir, file).replace(/\\/g, "/");
        const stat = await fs.stat(file);
        let info = manifest[rel];
        if (!info || info.mtimeMs !== stat.mtimeMs) {
          const built = await buildExport(file);
          info = { mtimeMs: stat.mtimeMs, ...built };
        }
        bar.increment();
        return { rel, info };
      }),
    ),
  );
  for (const { rel, info } of results) {
    if (info.name && used.has(info.name)) {
      nextManifest[rel] = info;
      continue;
    }
    if (info.name) {
      used.add(info.name);
    }
    exports.push(...info.lines);
    nextManifest[rel] = info;
  }
  bars.stop();
  await saveManifest(nextManifest);
  exports.push("");
  await fs.writeFile(indexFile, exports.join("\n"));
  console.log(`Generated ${path.relative(process.cwd(), indexFile)}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
